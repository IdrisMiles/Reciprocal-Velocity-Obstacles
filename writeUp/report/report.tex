\documentclass[a4paper,twocolumn]{article}
%\documentclass[a4paper]{article}
\usepackage{graphicx}
\usepackage{url}
\usepackage{amssymb}
%\usepackage{natbib}

%\addbibresource[<options for bib resources>]{<mybibfile>.bib}


%Set up title
\author{Idris Miles\\
Bournemouth University SDAGE level I}
\title{Local Avoidance Techniques for Real-Time Crowd Simulation}
\date{\today}

%begin the document
\begin{document}

\maketitle

\section*{Abstract}
In this paper I demonstrate the use of Reciprocal Velocity Obstacle, RVO, as a viable local avoidance model for real time agent based crowd simulation. \\

\section{Introduction}
Crowd simulation is a growing niche for films in the animation and VFX world, where complete CG worlds are brought to life with their own CG inhabitants. Of course it would be too much to ask animators to animate the 300 pedestrians in the background, or the thousands of fans in a sports arena. So the use of crowd simulation tools were bought to life. There are many different aspects involved in crowd simulation: behaviour of the characters, also known as agents, global navigation of the agents, local obstacle avoidance, the animation system, so the characters don't glide around, physics if you want characters to react appropriately to various effects, the list goes on.

\section{Local Avoidance in Crowd Simulation}
Local avoidance is the avoidance of agents within a close proximity of each other, it is useful when there are multiple moving objects in the world that the global navigation system may ignore, due to the fact their position is constantly changing. Global navigation differs from local avoidance because it looks at finding a route from one location to another, while local avoidance just considers its surroundings and desired direction and aims to avoid collisions while staying on track to its goal. Artificial Intelligence also differs from local avoidance although the two can be linked together, AI focuses on creating behaviours of the agents such as forming groups or separating from other types of agent/objects in the virtual world. AI can indirectly incorporate local avoidance due to the behaviours it may create but often this isn't enough to satisfy a collision free system, hence local avoidance can be 'layered' on top. Boids flocking and social forces are examples of behaviour that can result in indirect local avoidance however they are not enough on their own to guarantee it. Reciprocal Velocity Obstacle, RVO, is not a behaviour but is purely a form of local avoidance. It is the RVO technique that is the main focus of my project.

\section{Initial Research}
The first call of action was to make a time schedule that I would follow in order to keep on track, as time management would be crucial in this project.
\label{schedule}
\includegraphics[scale=0.2]{../schedule/specialistSchedule.png}
For my initial research I looked into the various methods used for local avoidance and what techniques current systems used. The three main methods I came across was Craig Reynolds Boids flocking system, Social forces and Reciprocal Velocity Obstacle. I felt flocking was not suitable as it was better for replicating animal behaviour such as birds rather than humans. Social forces is a very interesting technique that is better for producing human behaviours but not necessarily guaranteed object avoidance. Reciprocal Velocity Obstacle, RVO, is a method not so focused on the behaviour of the agent but rather a method that aims to choose an appropriate velocity that will not result in a collision. RVO is a technique used in various systems including Goalem crowd plugin for Maya and Unreal Engine 4. After this initial research I decided to focus on the use of RVO as it seemed the most suitable for my project.\\
I then set out to create UML diagrams to see how my code should be structured and how the various components fit together, to do this I looked into design patterns \cite{OODPWS}. The use of aggregation seemed required as I planned to dynamically add agents and boundaries into the system.\\
%UML diagram
\label{uml diagram}
\includegraphics[scale=0.13]{../umlDiagram/Agent_UML_diagram.png} 

\section{RVO}
RVO  is an agent based method for collision avoidance and was developed by Jur Van Den Burg et all \cite{JBerg2008RVO}. It is based upon a similar technique known as Velocity Obstacle (VO), and uses much of the same principle but with some critical tweaks, which was initially designed for motion planning of autonomous robots. However these techniques have been extended for use in crowd  simulation.


\subsection{How RVO Works}
\cite{DCherry2013RVO}
\cite{AGuy2009CP}
\cite{JBerg2008CS}
VO, which RVO is based from, works by the following:\\
\begin{center}
$VO^{A}_{B} (v_{B} ) = \{v_{A} | λ(p_{A} , v_{A} − v_{B} ) ∩ B ⊕ − A = ∅ \varnothing \}$
formula\\
\end{center}

This translates to, the velocity obstacle $VO^{A}_{B} (v B )$ of agent \emph{B} to \emph{A} is the set of velocities $V_{A}$ for \emph{A} that will result in a collision with \emph{B} moving at velocity $V_{B}$. The idea is to find a new velocity for the agent \emph{A} that is outside the VO of \emph{B}. The difference with RVO and VO is instead of finding a velocity outside the VO of \emph{B} we find the average between the velocity outside and the current velocity. This produces smoother movement of the agent and guarantees oscillation free movement which can be a common problem for local avoidance.

\subsection{RVO Implementation}
pseudo code of some form can probably go here.

\section{Optimizations}
Using hash table and Moving heavy computation to a compute shader. \cite{NOthman2013SP}
The first optimization I implemented was incorporating a hash table. The hash table speeds up the neighbour search considerably, rather than being of $O(n^{2})$ it becomes $O(n)$ this is because each agent is put into a "bucket" that is associated with its position, the hash table consists of an array of these "buckets", and to find the agents neighbours you simply have to query the "bucket" the agent belongs to and the neighbouring "buckets". A further optimization is to have the agent only search half the necessary neighbouring "buckets" and when ever it finds an agent, have each agent add each other to their neighbour list. This means that half the number of neighbour queries have to be completed.\\
The next optimization was not for speed increase but rather refining RVO. During times when the crowd became dense the agents could become very conservative with their movement, this is due to the shape of the VO cone produced that designates the undesirable velocities. The tip of the cone can be cut so that we have 3 edges to check against rather than 2\cite{AGuy2009CP}, although increasing the number of calculations it also increases the available velocities for the agent. Even still this is not enough at times, so we introduce a penalty factor for all velocities tested. This penalty is weighted upon the time to collision, smaller time = larger penalty, and also the difference between the tested velocity and desired velocity. The velocity with the smallest penalty is chosen and is also multiplied by \emph{t}, the time to collision, this means we can slow down the agent without having to sample too many velocities, only velocities of a different direction not magnitude. This is not perfect as it means some optimal velocities may be overshadowed however it is a quick method which is necessary for real-time applications.

\section{Conclusion and Future Work}
I am pleased with the outcome of the project as I feel I was successful in investigating local avoidance techniques focusing on real-time requirements. My implementation is proof off the success of the research.


%\bibliographystyle{plainnat}
\bibliographystyle{plain_annote}
\bibliography{references}



\end{document}
